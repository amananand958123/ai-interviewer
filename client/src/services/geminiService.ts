interface GeminiQuestion {
  id: number
  text: string
  category: string
  difficulty: 'Easy' | 'Medium' | 'Hard'
  expectedPoints: string[]
  techStack: string
}

interface GeminiResponse {
  candidates: Array<{
    content: {
      parts: Array<{
        text: string
      }>
    }
  }>
}

class GeminiService {
  private apiKey: string
  private baseUrl: string
  private model: string

  constructor() {
    // Get API key and model from environment variables
    this.apiKey = (import.meta as any).env?.VITE_GEMINI_API_KEY || 'AIzaSyDxg79HFqGEBmg7_nEve8HSLjOE0uo0rB8'
    this.model = (import.meta as any).env?.VITE_GEMINI_MODEL || 'gemini-2.0-flash'
    this.baseUrl = `https://generativelanguage.googleapis.com/v1beta/models/${this.model}:generateContent`
  }

  async generateQuestions(
    techStack: string, 
    level: string, 
    count: number = 5
  ): Promise<GeminiQuestion[]> {
    try {
      // For demo purposes, if no API key is set, return mock questions
      if (this.apiKey === 'demo-key' || !this.apiKey) {
        console.log('Using demo mode - no API key provided')
        return this.getMockQuestions(techStack, level, count)
      }

      console.log(`Generating ${count} questions for ${techStack} at ${level} level using ${this.model}`)
      
      const difficulty = this.mapLevelToDifficulty(level)
      const prompt = this.createPrompt(techStack, difficulty, count)

      const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }],
          generationConfig: {
            temperature: 0.7,
            topK: 40,
            topP: 0.95,
            maxOutputTokens: 2048,
          }
        })
      })

      if (!response.ok) {
        const errorText = await response.text()
        if (response.status === 429) {
          console.warn('⚠️ Gemini API rate limit reached. Using fallback questions.')
          // Fallback to mock questions when rate limited
          return this.getMockQuestions(techStack, level, count)
        }
        console.error(`Gemini API error: ${response.status} - ${errorText}`)
        throw new Error(`Gemini API error: ${response.status}`)
      }

      const data: GeminiResponse = await response.json()
      const generatedText = data.candidates[0]?.content?.parts[0]?.text

      if (!generatedText) {
        console.error('No content generated by Gemini')
        throw new Error('No content generated by Gemini')
      }

      console.log('Successfully generated questions from Gemini API')
      return this.parseGeminiResponse(generatedText, techStack)
    } catch (error) {
      console.error('Error generating questions with Gemini:', error)
      // Fallback to mock questions if Gemini fails
      return this.getMockQuestions(techStack, level, count)
    }
  }

  // Test method to verify API connectivity
  async testConnection(): Promise<boolean> {
    try {
      if (this.apiKey === 'demo-key') {
        console.log('Demo mode - no API key provided')
        return false
      }

      console.log('Testing Gemini API connection...')
      
      const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: 'Say "Hello" to test the connection.'
            }]
          }]
        })
      })

      if (response.ok) {
        console.log('✅ Gemini API connection successful')
        return true
      } else if (response.status === 429) {
        console.warn('⚠️ Gemini API rate limit reached (429). Please wait before making more requests.')
        return false
      } else {
        console.error('❌ Gemini API connection failed:', response.status)
        return false
      }
    } catch (error) {
      console.error('❌ Gemini API connection error:', error)
      return false
    }
  }

  private mapLevelToDifficulty(level: string): string[] {
    const difficultyMap: Record<string, string[]> = {
      'Basic': ['Easy'],
      'Intermediate': ['Easy', 'Medium'],
      'Pro': ['Medium', 'Hard']
    }
    return difficultyMap[level] || ['Easy', 'Medium', 'Hard']
  }

  private createPrompt(techStack: string, difficulties: string[], count: number): string {
    return `You are an expert technical interviewer. Generate ${count} high-quality technical interview questions for ${techStack} programming.

REQUIREMENTS:
- Difficulty levels: ${difficulties.join(', ')}
- Questions should be realistic and commonly asked in actual interviews
- Focus on practical knowledge and problem-solving skills
- Include a mix of conceptual and hands-on questions

OUTPUT FORMAT (JSON only, no markdown):
[
  {
    "id": 1,
    "text": "Clear, specific question text",
    "category": "Relevant category name",
    "difficulty": "Easy|Medium|Hard",
    "expectedPoints": ["Key point 1", "Key point 2", "Key point 3", "Key point 4"],
    "techStack": "${techStack}"
  }
]

GUIDELINES:
- ${techStack} specific questions only
- Categories: Core Concepts, Best Practices, Advanced Features, Problem Solving, System Design, Performance, Security
- Expected points should be 3-5 key concepts the candidate should mention
- Questions should test understanding, not memorization
- Vary question types: explain concepts, compare approaches, solve problems, design systems
- Make questions interview-appropriate (not too academic or too simple)

Generate exactly ${count} questions and return only the JSON array.`
  }

  private parseGeminiResponse(response: string, techStack: string): GeminiQuestion[] {
    try {
      console.log('Raw Gemini response:', response.substring(0, 200) + '...')
      
      // Clean the response to extract JSON - handle various formats
      let jsonText = response
      
      // Remove markdown code blocks if present
      jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '')
      
      // Find JSON array in the response
      const jsonMatch = jsonText.match(/\[[\s\S]*\]/)
      if (!jsonMatch) {
        console.error('No JSON array found in response')
        throw new Error('No JSON array found in response')
      }

      const questions = JSON.parse(jsonMatch[0])
      
      if (!Array.isArray(questions)) {
        throw new Error('Response is not an array')
      }
      
      console.log(`Successfully parsed ${questions.length} questions`)
      
      // Validate and clean the questions
      return questions.map((q: any, index: number) => ({
        id: q.id || index + 1,
        text: q.text || 'Generated question',
        category: q.category || `${techStack} Interview`,
        difficulty: ['Easy', 'Medium', 'Hard'].includes(q.difficulty) ? q.difficulty : 'Medium',
        expectedPoints: Array.isArray(q.expectedPoints) ? q.expectedPoints : ['Answer should demonstrate understanding'],
        techStack: techStack
      }))
    } catch (error) {
      console.error('Error parsing Gemini response:', error)
      console.error('Raw response:', response)
      throw new Error('Failed to parse generated questions')
    }
  }

  private getMockQuestions(techStack: string, level: string, count: number): GeminiQuestion[] {
    // Enhanced mock questions based on level
    const baseQuestions: Omit<GeminiQuestion, 'id'>[] = []

    if (level === 'Basic') {
      baseQuestions.push(
        {
          text: `What are the basic data types in ${techStack}?`,
          category: `${techStack} Fundamentals`,
          difficulty: 'Easy',
          expectedPoints: ['Primitive types', 'Reference types', 'Type checking', 'Variable declaration'],
          techStack
        },
        {
          text: `Explain variable scope in ${techStack}.`,
          category: `${techStack} Basics`,
          difficulty: 'Easy',
          expectedPoints: ['Global scope', 'Function scope', 'Block scope', 'Variable hoisting'],
          techStack
        }
      )
    }

    if (level === 'Intermediate' || level === 'Basic') {
      baseQuestions.push(
        {
          text: `How does error handling work in ${techStack}?`,
          category: `${techStack} Error Management`,
          difficulty: 'Medium',
          expectedPoints: ['Try-catch blocks', 'Error types', 'Best practices', 'Error propagation'],
          techStack
        },
        {
          text: `What are the best practices for ${techStack} performance optimization?`,
          category: `${techStack} Performance`,
          difficulty: 'Medium',
          expectedPoints: ['Code optimization', 'Memory management', 'Algorithm efficiency', 'Profiling tools'],
          techStack
        }
      )
    }

    if (level === 'Pro') {
      baseQuestions.push(
        {
          text: `Explain advanced ${techStack} design patterns and their use cases.`,
          category: `${techStack} Architecture`,
          difficulty: 'Hard',
          expectedPoints: ['Design patterns', 'Architectural decisions', 'Scalability', 'Maintainability'],
          techStack
        },
        {
          text: `How would you implement a complex system using ${techStack}?`,
          category: `${techStack} System Design`,
          difficulty: 'Hard',
          expectedPoints: ['System architecture', 'Component design', 'Data flow', 'Testing strategy'],
          techStack
        }
      )
    }

    // Add more questions to reach the count
    while (baseQuestions.length < count) {
      baseQuestions.push({
        text: `Describe a challenging ${techStack} project you've worked on and how you solved technical difficulties.`,
        category: `${techStack} Experience`,
        difficulty: level === 'Basic' ? 'Easy' : level === 'Intermediate' ? 'Medium' : 'Hard',
        expectedPoints: ['Problem description', 'Solution approach', 'Technical challenges', 'Lessons learned'],
        techStack
      })
    }

    return baseQuestions.slice(0, count).map((q, index) => ({
      id: index + 1,
      ...q
    }))
  }
}

export const geminiService = new GeminiService()
export type { GeminiQuestion }

// Test the API connection on initialization
geminiService.testConnection()
