interface GeminiQuestion {
  id: number
  text: string
  category: string
  difficulty: 'Easy' | 'Medium' | 'Hard'
  expectedPoints: string[]
  techStack: string
}

interface GeminiResponse {
  candidates: Array<{
    content: {
      parts: Array<{
        text: string
      }>
    }
  }>
}

class GeminiService {
  private apiKey: string
  private baseUrl: string
  private model: string

  constructor() {
    // Get API key and model from environment variables
    this.apiKey = (import.meta as any).env?.VITE_GEMINI_API_KEY || 'AIzaSyDxg79HFqGEBmg7_nEve8HSLjOE0uo0rB8'
    this.model = (import.meta as any).env?.VITE_GEMINI_MODEL || 'gemini-2.0-flash'
    this.baseUrl = `https://generativelanguage.googleapis.com/v1beta/models/${this.model}:generateContent`
  }

  async generateQuestions(
    techStack: string, 
    level: string, 
    count: number = 5
  ): Promise<GeminiQuestion[]> {
    try {
      // For demo purposes, if no API key is set, return mock questions
      if (this.apiKey === 'demo-key' || !this.apiKey) {
        console.log('Using demo mode - no API key provided')
        return this.getMockQuestions(techStack, level, count)
      }

      console.log(`Generating ${count} questions for ${techStack} at ${level} level using ${this.model}`)
      
      const difficulty = this.mapLevelToDifficulty(level)
      const prompt = this.createPrompt(techStack, difficulty, count)

      const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }],
          generationConfig: {
            temperature: 0.7,
            topK: 40,
            topP: 0.95,
            maxOutputTokens: 2048,
          }
        })
      })

      if (!response.ok) {
        const errorText = await response.text()
        if (response.status === 429) {
          console.warn('⚠️ Gemini API rate limit reached. Using fallback questions.')
          // Fallback to mock questions when rate limited
          return this.getMockQuestions(techStack, level, count)
        }
        console.error(`Gemini API error: ${response.status} - ${errorText}`)
        throw new Error(`Gemini API error: ${response.status}`)
      }

      const data: GeminiResponse = await response.json()
      const generatedText = data.candidates[0]?.content?.parts[0]?.text

      if (!generatedText) {
        console.error('No content generated by Gemini')
        throw new Error('No content generated by Gemini')
      }

      console.log('Successfully generated questions from Gemini API')
      return this.parseGeminiResponse(generatedText, techStack)
    } catch (error) {
      console.error('Error generating questions with Gemini:', error)
      // Fallback to mock questions if Gemini fails
      return this.getMockQuestions(techStack, level, count)
    }
  }

  // Test method to verify API connectivity
  async testConnection(): Promise<boolean> {
    try {
      if (this.apiKey === 'demo-key') {
        console.log('Demo mode - no API key provided')
        return false
      }

      console.log('Testing Gemini API connection...')
      
      const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: 'Say "Hello" to test the connection.'
            }]
          }]
        })
      })

      if (response.ok) {
        console.log('✅ Gemini API connection successful')
        return true
      } else if (response.status === 429) {
        console.warn('⚠️ Gemini API rate limit reached (429). Please wait before making more requests.')
        return false
      } else {
        console.error('❌ Gemini API connection failed:', response.status)
        return false
      }
    } catch (error) {
      console.error('❌ Gemini API connection error:', error)
      return false
    }
  }

  private mapLevelToDifficulty(level: string): string[] {
    const difficultyMap: Record<string, string[]> = {
      'Basic': ['Easy'],
      'Intermediate': ['Easy', 'Medium'],
      'Pro': ['Medium', 'Hard']
    }
    return difficultyMap[level] || ['Easy', 'Medium', 'Hard']
  }

  private createPrompt(techStack: string, difficulties: string[], count: number): string {
    return `You are an expert technical interviewer. Generate ${count} high-quality technical interview questions for ${techStack} programming.

REQUIREMENTS:
- Difficulty levels: ${difficulties.join(', ')}
- Questions should be realistic and commonly asked in actual interviews
- Focus on practical knowledge and problem-solving skills
- Include a mix of conceptual and hands-on questions

OUTPUT FORMAT (JSON only, no markdown):
[
  {
    "id": 1,
    "text": "Clear, specific question text",
    "category": "Relevant category name",
    "difficulty": "Easy|Medium|Hard",
    "expectedPoints": ["Key point 1", "Key point 2", "Key point 3", "Key point 4"],
    "techStack": "${techStack}"
  }
]

GUIDELINES:
- ${techStack} specific questions only
- Categories: Core Concepts, Best Practices, Advanced Features, Problem Solving, System Design, Performance, Security
- Expected points should be 3-5 key concepts the candidate should mention
- Questions should test understanding, not memorization
- Vary question types: explain concepts, compare approaches, solve problems, design systems
- Make questions interview-appropriate (not too academic or too simple)

Generate exactly ${count} questions and return only the JSON array.`
  }

  private parseGeminiResponse(response: string, techStack: string): GeminiQuestion[] {
    try {
      console.log('Raw Gemini response:', response.substring(0, 200) + '...')
      
      // Clean the response to extract JSON - handle various formats
      let jsonText = response
      
      // Remove markdown code blocks if present
      jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '')
      
      // Find JSON array in the response
      const jsonMatch = jsonText.match(/\[[\s\S]*\]/)
      if (!jsonMatch) {
        console.error('No JSON array found in response')
        throw new Error('No JSON array found in response')
      }

      const questions = JSON.parse(jsonMatch[0])
      
      if (!Array.isArray(questions)) {
        throw new Error('Response is not an array')
      }
      
      console.log(`Successfully parsed ${questions.length} questions`)
      
      // Validate and clean the questions
      return questions.map((q: any, index: number) => ({
        id: q.id || index + 1,
        text: q.text || 'Generated question',
        category: q.category || `${techStack} Interview`,
        difficulty: ['Easy', 'Medium', 'Hard'].includes(q.difficulty) ? q.difficulty : 'Medium',
        expectedPoints: Array.isArray(q.expectedPoints) ? q.expectedPoints : ['Answer should demonstrate understanding'],
        techStack: techStack
      }))
    } catch (error) {
      console.error('Error parsing Gemini response:', error)
      console.error('Raw response:', response)
      throw new Error('Failed to parse generated questions')
    }
  }

  private getMockQuestions(techStack: string, level: string, count: number): GeminiQuestion[] {
    // Enhanced mock questions based on level
    const baseQuestions: Omit<GeminiQuestion, 'id'>[] = []

    if (level === 'Basic') {
      baseQuestions.push(
        {
          text: `What are the basic data types in ${techStack}?`,
          category: `${techStack} Fundamentals`,
          difficulty: 'Easy',
          expectedPoints: ['Primitive types', 'Reference types', 'Type checking', 'Variable declaration'],
          techStack
        },
        {
          text: `Explain variable scope in ${techStack}.`,
          category: `${techStack} Basics`,
          difficulty: 'Easy',
          expectedPoints: ['Global scope', 'Function scope', 'Block scope', 'Variable hoisting'],
          techStack
        }
      )
    }

    if (level === 'Intermediate' || level === 'Basic') {
      baseQuestions.push(
        {
          text: `How does error handling work in ${techStack}?`,
          category: `${techStack} Error Management`,
          difficulty: 'Medium',
          expectedPoints: ['Try-catch blocks', 'Error types', 'Best practices', 'Error propagation'],
          techStack
        },
        {
          text: `What are the best practices for ${techStack} performance optimization?`,
          category: `${techStack} Performance`,
          difficulty: 'Medium',
          expectedPoints: ['Code optimization', 'Memory management', 'Algorithm efficiency', 'Profiling tools'],
          techStack
        }
      )
    }

    if (level === 'Pro') {
      baseQuestions.push(
        {
          text: `Explain advanced ${techStack} design patterns and their use cases.`,
          category: `${techStack} Architecture`,
          difficulty: 'Hard',
          expectedPoints: ['Design patterns', 'Architectural decisions', 'Scalability', 'Maintainability'],
          techStack
        },
        {
          text: `How would you implement a complex system using ${techStack}?`,
          category: `${techStack} System Design`,
          difficulty: 'Hard',
          expectedPoints: ['System architecture', 'Component design', 'Data flow', 'Testing strategy'],
          techStack
        }
      )
    }

    // Add more questions to reach the count
    while (baseQuestions.length < count) {
      baseQuestions.push({
        text: `Describe a challenging ${techStack} project you've worked on and how you solved technical difficulties.`,
        category: `${techStack} Experience`,
        difficulty: level === 'Basic' ? 'Easy' : level === 'Intermediate' ? 'Medium' : 'Hard',
        expectedPoints: ['Problem description', 'Solution approach', 'Technical challenges', 'Lessons learned'],
        techStack
      })
    }

    return baseQuestions.slice(0, count).map((q, index) => ({
      id: index + 1,
      ...q
    }))
  }

  // Generate dynamic boilerplate code for coding challenges
  async generateBoilerplateCode(
    challenge: any,
    language: string
  ): Promise<string> {
    try {
      // For demo purposes, if no API key is set, return fallback boilerplate
      if (this.apiKey === 'demo-key' || !this.apiKey) {
        console.log('Using demo mode - generating fallback boilerplate')
        return this.getFallbackBoilerplate(challenge, language)
      }

      console.log(`Generating boilerplate code for ${language} using ${this.model}`)
      
      const prompt = this.createBoilerplatePrompt(challenge, language)

      const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }],
          generationConfig: {
            temperature: 0.3, // Lower temperature for more consistent code generation
            topK: 20,
            topP: 0.8,
            maxOutputTokens: 1024,
          }
        })
      })

      if (!response.ok) {
        const errorText = await response.text()
        if (response.status === 429) {
          console.warn('⚠️ Gemini API rate limit reached. Using fallback boilerplate.')
          return this.getFallbackBoilerplate(challenge, language)
        }
        console.error(`Gemini API error: ${response.status} - ${errorText}`)
        throw new Error(`Gemini API error: ${response.status}`)
      }

      const data: GeminiResponse = await response.json()
      const generatedCode = data.candidates[0]?.content?.parts[0]?.text

      if (!generatedCode) {
        console.error('No boilerplate code generated by Gemini')
        return this.getFallbackBoilerplate(challenge, language)
      }

      // Clean up the generated code
      const cleanedCode = this.cleanGeneratedCode(generatedCode)
      console.log('Successfully generated boilerplate code from Gemini API')
      return cleanedCode
    } catch (error) {
      console.error('Error generating boilerplate code with Gemini:', error)
      // Fallback to basic boilerplate if Gemini fails
      return this.getFallbackBoilerplate(challenge, language)
    }
  }

  private createBoilerplatePrompt(challenge: any, language: string): string {
    return `Generate a clean, minimal boilerplate code template for the following coding challenge in ${language}:

CHALLENGE: ${challenge.title}
DESCRIPTION: ${challenge.description}
DIFFICULTY: ${challenge.difficulty}

REQUIREMENTS:
1. Create a starter function/method with proper signature based on the challenge description
2. Include minimal but helpful comments
3. Use appropriate parameter names and types for ${language}
4. Follow ${language} best practices and naming conventions
5. Include a TODO comment where the main logic should go
6. Return appropriate default/placeholder value
7. Do NOT include any actual solution logic - just the template structure
8. For C++: Include a protected main() function that users should NOT modify
9. Add clear comments indicating which parts users can/cannot modify

LANGUAGE SPECIFIC REQUIREMENTS:
${this.getLanguageSpecificRequirements(language)}

EXAMPLE INPUT/OUTPUT (if available):
${challenge.testCases ? challenge.testCases.slice(0, 2).map((tc: any, i: number) => 
  `Example ${i + 1}: Input: ${tc.input}, Output: ${tc.expectedOutput}`).join('\n') : 'No examples provided'}

Generate ONLY the boilerplate code without any explanation or markdown formatting. The code should be ready to run with a placeholder return value.`
  }

  private getLanguageSpecificRequirements(language: string): string {
    const requirements: Record<string, string> = {
      'javascript': `
- Use function declaration or arrow function syntax
- Use camelCase for function and variable names
- Include JSDoc comment if function is complex
- Use const/let appropriately
- Return null or appropriate default value`,
      
      'python': `
- Use snake_case for function and variable names
- Include type hints if appropriate
- Use proper Python docstring format
- Follow PEP 8 style guidelines
- Return None or appropriate default value`,
      
      'java': `
- Use proper Java class structure with public static methods
- Use camelCase for method names, PascalCase for classes
- Include proper method signature with return type
- Use appropriate Java data types (int, String, List, etc.)
- Return null or appropriate default value`,
      
      'cpp': `
- Use proper C++ syntax with necessary includes (#include <iostream>, <vector>, <string>, <algorithm>)
- Create a standalone function (NOT inside a class)
- Use appropriate C++ data types (int, double, string, vector<int>, etc.)
- Include a simple main() function for testing that should NOT be modified by users
- Add comment "// DO NOT MODIFY THE CODE BELOW" before main function
- The main function should be minimal and just return 0
- Function should use clear parameter names based on the problem
- Return appropriate default value for the expected output type`,
      
      'csharp': `
- Use proper C# class structure with public static methods
- Use PascalCase for method names and classes
- Include proper method signature with return type
- Use appropriate C# data types (int, string, List, etc.)
- Return null or appropriate default value`,
      
      'typescript': `
- Use TypeScript type annotations
- Use camelCase for function and variable names
- Include proper function signature with parameter and return types
- Use interface or type definitions if needed
- Return null or appropriate default value`
    }
    
    return requirements[language] || requirements['javascript']
  }

  private cleanGeneratedCode(code: string): string {
    // Remove markdown code blocks if present
    let cleaned = code.replace(/```[\w]*\n?/g, '').replace(/```/g, '')
    
    // Remove any explanation text before or after code
    const lines = cleaned.split('\n')
    let startIndex = 0
    let endIndex = lines.length - 1
    
    // Find the first line that looks like code
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim()
      if (line.includes('function') || line.includes('def ') || line.includes('public ') || 
          line.includes('#include') || line.includes('class ') || line.includes('const ') ||
          line.includes('let ') || line.includes('var ') || line.includes('//') || line.includes('/*')) {
        startIndex = i
        break
      }
    }
    
    // Find the last line that looks like code
    for (let i = lines.length - 1; i >= 0; i--) {
      const line = lines[i].trim()
      if (line.includes('}') || line.includes('return') || line.includes('pass') || 
          line.includes(';') || line.includes('TODO') || line.includes('//')) {
        endIndex = i
        break
      }
    }
    
    cleaned = lines.slice(startIndex, endIndex + 1).join('\n').trim()
    
    // Remove any remaining explanatory text
    cleaned = cleaned.replace(/^Here's.*?:/gm, '')
    cleaned = cleaned.replace(/^This.*?:/gm, '')
    cleaned = cleaned.replace(/^The.*?:/gm, '')
    
    return cleaned.trim()
  }

  private getFallbackBoilerplate(challenge: any, language: string): string {
    // Simple fallback boilerplate generation
    const functionName = this.extractFunctionName(challenge.description) || 'solution'
    
    switch (language) {
      case 'javascript':
        return `function ${functionName}(input) {
  // TODO: Implement your solution here
  return null;
}`
      
      case 'python':
        return `def ${functionName}(input):
    """
    TODO: Implement your solution here
    """
    return None`
      
      case 'java':
        return `public class Solution {
    public static Object ${functionName}(Object input) {
        // TODO: Implement your solution here
        return null;
    }
}`
      
      case 'cpp':
        return `#include <iostream>
#include <vector>
using namespace std;

auto ${functionName}(auto input) {
    // TODO: Implement your solution here
    return nullptr;
}`
      
      default:
        return `function ${functionName}(input) {
  // TODO: Implement your solution here
  return null;
}`
    }
  }

  private extractFunctionName(description: string): string {
    // Try to extract function name from description
    const matches = description.match(/`(\w+)\(`/)
    if (matches && matches[1]) {
      return matches[1]
    }
    
    // Look for common patterns
    if (description.toLowerCase().includes('calculate')) return 'calculate'
    if (description.toLowerCase().includes('find')) return 'find'
    if (description.toLowerCase().includes('sort')) return 'sort'
    if (description.toLowerCase().includes('search')) return 'search'
    if (description.toLowerCase().includes('count')) return 'count'
    if (description.toLowerCase().includes('sum')) return 'sum'
    if (description.toLowerCase().includes('average')) return 'calculateAverage'
    
    return 'solution'
  }

  // Execute code using Gemini AI
  async executeCode(
    code: string, 
    language: string, 
    testCases: Array<{input: any, expectedOutput: any, description?: string}>
  ): Promise<{
    success: boolean,
    results: Array<{
      success: boolean,
      output: string,
      error?: string,
      executionTime?: number,
      memoryUsage?: number,
      input: any,
      expectedOutput: any
    }>,
    error?: string
  }> {
    try {
      console.log(`Executing ${language} code using Gemini AI`)
      
      // For demo purposes, if no API key is set, return mock results
      if (this.apiKey === 'demo-key' || !this.apiKey) {
        console.log('Using demo mode - no API key provided')
        return this.getMockExecutionResults(testCases)
      }

      const prompt = this.createCodeExecutionPrompt(code, language, testCases)
      
      const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }],
          generationConfig: {
            temperature: 0.1, // Very low temperature for consistent execution results
            topK: 1,
            topP: 0.1,
            maxOutputTokens: 4096,
          }
        })
      })

      if (!response.ok) {
        const errorText = await response.text()
        if (response.status === 429) {
          console.warn('⚠️ Gemini API rate limit reached. Using fallback execution.')
          return this.getMockExecutionResults(testCases)
        }
        throw new Error(`Gemini API error: ${response.status} - ${errorText}`)
      }

      const data: GeminiResponse = await response.json()
      const executionResult = data.candidates[0]?.content?.parts[0]?.text

      if (!executionResult) {
        throw new Error('No execution result from Gemini')
      }

      console.log('Successfully executed code using Gemini AI')
      return this.parseExecutionResult(executionResult, testCases)
      
    } catch (error) {
      console.error('Error executing code with Gemini:', error)
      return {
        success: false,
        results: testCases.map(testCase => ({
          success: false,
          output: 'Execution failed',
          error: error instanceof Error ? error.message : 'Unknown error occurred',
          executionTime: 0,
          memoryUsage: 0,
          input: testCase.input,
          expectedOutput: testCase.expectedOutput
        })),
        error: error instanceof Error ? error.message : 'Unknown error occurred'
      }
    }
  }

  private createCodeExecutionPrompt(
    code: string, 
    language: string, 
    testCases: Array<{input: any, expectedOutput: any}>
  ): string {
    return `You are a code execution engine. Execute the following ${language} code with the provided test cases and return the results in a specific JSON format.

CODE TO EXECUTE:
\`\`\`${language}
${code}
\`\`\`

TEST CASES:
${testCases.map((tc, i) => `Test Case ${i + 1}: Input: ${JSON.stringify(tc.input)} | Expected: ${JSON.stringify(tc.expectedOutput)}`).join('\n')}

INSTRUCTIONS:
1. Execute the code with each test case input
2. Compare actual output with expected output
3. Return results in the exact JSON format below
4. If there are syntax errors or runtime errors, capture them
5. For successful execution, provide the actual output
6. Determine if each test case passed (actual output matches expected)

REQUIRED RESPONSE FORMAT (JSON only, no markdown):
{
  "success": true/false,
  "results": [
    {
      "success": true/false,
      "output": "actual output as string",
      "error": "error message if any" or null,
      "executionTime": estimated_ms,
      "memoryUsage": estimated_kb,
      "input": test_case_input,
      "expectedOutput": expected_output
    }
  ]
}

EXECUTION RULES:
- For JavaScript: Call the function with the test input
- For Python: Call the function with the test input  
- For Java: Execute the method with the test input
- For C++: Compile and run with the test input
- Handle array inputs by passing them correctly to the function
- Handle object inputs by destructuring if needed
- If the function expects multiple parameters, spread array inputs
- If code has compilation errors, mark all tests as failed
- If code has runtime errors, capture the error for that specific test

Return ONLY the JSON response, no additional text or explanation.`
  }

  private parseExecutionResult(
    result: string, 
    testCases: Array<{input: any, expectedOutput: any}>
  ): {
    success: boolean,
    results: Array<{
      success: boolean,
      output: string,
      error?: string,
      executionTime?: number,
      memoryUsage?: number,
      input: any,
      expectedOutput: any
    }>,
    error?: string
  } {
    try {
      // Clean the result to extract JSON
      const cleanResult = result.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim()
      const parsedResult = JSON.parse(cleanResult)
      
      // Validate the structure
      if (!parsedResult.results || !Array.isArray(parsedResult.results)) {
        throw new Error('Invalid result structure from Gemini')
      }
      
      // Ensure we have results for all test cases
      const results = parsedResult.results.map((result: any, index: number) => ({
        success: result.success || false,
        output: String(result.output || ''),
        error: result.error || undefined,
        executionTime: result.executionTime || Math.floor(Math.random() * 100),
        memoryUsage: result.memoryUsage || Math.floor(Math.random() * 1000),
        input: testCases[index]?.input,
        expectedOutput: testCases[index]?.expectedOutput
      }))
      
      const overallSuccess = results.every((r: any) => r.success)
      
      return {
        success: overallSuccess,
        results: results
      }
      
    } catch (parseError) {
      console.error('Error parsing Gemini execution result:', parseError)
      console.error('Raw result:', result)
      
      // Fallback parsing for cases where Gemini doesn't return perfect JSON
      return this.getMockExecutionResults(testCases)
    }
  }

  private getMockExecutionResults(testCases: Array<{input: any, expectedOutput: any}>) {
    // Create realistic mock results for demo/fallback purposes
    const results = testCases.map((testCase) => {
      // Simulate some passing and some failing for demo
      const shouldPass = Math.random() > 0.3 // 70% pass rate for demo
      
      return {
        success: shouldPass,
        output: shouldPass ? String(testCase.expectedOutput) : 'Mock output',
        error: shouldPass ? undefined : 'Mock execution error',
        executionTime: Math.floor(Math.random() * 150),
        memoryUsage: Math.floor(Math.random() * 2000),
        input: testCase.input,
        expectedOutput: testCase.expectedOutput
      }
    })
    
    return {
      success: results.every(r => r.success),
      results: results
    }
  }
}

export const geminiService = new GeminiService()
export type { GeminiQuestion }

// Test the API connection on initialization
geminiService.testConnection()
