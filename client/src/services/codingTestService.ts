const API_URL = 'http://localhost:3001/api';

export const generateChallenge = async (techStack: string, difficulty: string) => {
  console.log(`🎯 Generating ${difficulty} ${techStack} challenge...`);
  
  try {
    // Try backend first
    const response = await fetch(`${API_URL}/coding/generate-challenge`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      credentials: 'include',
      body: JSON.stringify({
        techStack,
        difficulty,
        count: 1,
      }),
    });

    if (response.ok) {
      const data = await response.json();
      if (data.success && data.challenges && data.challenges.length > 0) {
        console.log('✅ Backend challenge generated successfully');
        return data.challenges[0];
      }
    }
    
    throw new Error('Backend failed or returned invalid data');
  } catch (error) {
    console.warn('❌ Backend failed, trying Gemini API:', error);
    
    // Fallback to Gemini API
    try {
      const challenge = await generateChallengeWithGemini(techStack, difficulty);
      console.log('✅ Gemini challenge generated successfully');
      return challenge;
    } catch (geminiError) {
      console.warn('❌ Gemini also failed:', geminiError);
      
      // Final fallback to predefined challenges
      console.log('📚 Using predefined fallback challenge');
      return getFallbackChallenge(techStack, difficulty);
    }
  }
};

const generateChallengeWithGemini = async (techStack: string, difficulty: string) => {
  console.log(`🤖 Generating ${difficulty} ${techStack} challenge with Gemini...`);
  
  const prompt = `Generate a coding challenge for ${techStack} at ${difficulty} level.

Requirements:
- Return a JSON object with the following structure
- Include a clear problem description with examples
- Provide appropriate starter code for ${techStack}
- Include 3-5 test cases with realistic input/output pairs
- Make the challenge appropriate for ${difficulty} level

JSON Format:
{
  "id": 1,
  "title": "Challenge Title",
  "description": "Clear problem description with examples and constraints",
  "difficulty": "${difficulty}",
  "techStack": "${techStack}",
  "starterCode": "// Appropriate starter code for ${techStack}",
  "testCases": [
    {
      "input": "realistic test input",
      "expectedOutput": "expected result",
      "description": "test case description"
    }
  ],
  "timeLimit": 30
}

Generate exactly one high-quality coding challenge and return only the JSON object.`;

  try {
    console.log('📡 Sending request to Gemini API...');
    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDxg79HFqGEBmg7_nEve8HSLjOE0uo0rB8`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: prompt
          }]
        }],
        generationConfig: {
          temperature: 0.7,
          maxOutputTokens: 2048,
        }
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Gemini API error:', response.status, errorText);
      throw new Error(`Gemini API request failed: ${response.status}`);
    }

    const data = await response.json();
    console.log('📨 Received response from Gemini');
    
    const generatedText = data.candidates[0]?.content?.parts[0]?.text;

    if (!generatedText) {
      throw new Error('No content generated by Gemini');
    }

    console.log('🔍 Parsing Gemini response...');
    
    // Clean and extract JSON from response
    let jsonText = generatedText.trim();
    
    // Remove markdown code blocks if present
    jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '');
    
    // Find JSON object in the response
    const jsonMatch = jsonText.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      console.error('No JSON found in response:', generatedText.substring(0, 200));
      throw new Error('No JSON found in Gemini response');
    }

    const challenge = JSON.parse(jsonMatch[0]);
    console.log('✅ Successfully parsed challenge from Gemini');
    
    // Validate the challenge structure
    if (!challenge.title || !challenge.description || !challenge.starterCode) {
      throw new Error('Invalid challenge structure from Gemini');
    }
    
    return challenge;
  } catch (error) {
    console.error('❌ Gemini challenge generation failed:', error);
    throw error;
  }
};

const getFallbackChallenge = (techStack: string, difficulty: string) => {
  console.log(`📚 Getting fallback challenge for ${techStack} ${difficulty}`);
  
  const challenges = {
    'JavaScript': {
      'Easy': {
        id: 1,
        title: "Two Sum Problem",
        description: "Given an array of integers `nums` and an integer `target`, find two distinct numbers in the array that add up to the target. Return the indices of the two numbers that add up to the target. You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nExample: nums = [2, 7, 11, 15], target = 9\nReturn [0, 1] because nums[0] + nums[1] == 9.",
        difficulty: "Easy",
        techStack: "JavaScript",
        starterCode: `function twoSum(nums, target) {
    // Your code here
    return [];
}

// Test your function
console.log(twoSum([2, 7, 11, 15], 9)); // Should return [0, 1]`,
        testCases: [
          {
            input: [2, 7, 11, 15],
            expectedOutput: [0, 1],
            description: "Numbers at index 0 and 1 add up to 9"
          },
          {
            input: [3, 2, 4],
            expectedOutput: [1, 2],
            description: "Numbers at index 1 and 2 add up to 6"
          },
          {
            input: [3, 3],
            expectedOutput: [0, 1],
            description: "Duplicate numbers at different indices"
          }
        ],
        timeLimit: 30
      },
      'Medium': {
        id: 2,
        title: "String Palindrome Checker",
        description: "Write a function that checks if a given string is a palindrome. Ignore case, spaces, and punctuation. A palindrome reads the same forwards and backwards.",
        difficulty: "Medium",
        techStack: "JavaScript",
        starterCode: `function isPalindrome(str) {
  // Your code here
  return false;
}

// Test your function
console.log(isPalindrome("racecar")); // Should return true
console.log(isPalindrome("hello")); // Should return false`,
        testCases: [
          {
            input: "racecar",
            expectedOutput: true,
            description: "Simple palindrome"
          },
          {
            input: "A man a plan a canal Panama",
            expectedOutput: true,
            description: "Palindrome with spaces and mixed case"
          },
          {
            input: "hello",
            expectedOutput: false,
            description: "Not a palindrome"
          },
          {
            input: "Was it a car or a cat I saw?",
            expectedOutput: true,
            description: "Palindrome with punctuation"
          }
        ],
        timeLimit: 30
      },
      'Hard': {
        id: 3,
        title: "Binary Tree Maximum Depth",
        description: "Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
        difficulty: "Hard",
        techStack: "JavaScript",
        starterCode: `// Definition for a binary tree node
function TreeNode(val, left, right) {
    this.val = (val === undefined ? 0 : val);
    this.left = (left === undefined ? null : left);
    this.right = (right === undefined ? null : right);
}

function maxDepth(root) {
    // Your code here
    return 0;
}`,
        testCases: [
          {
            input: "TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))",
            expectedOutput: 3,
            description: "Binary tree with depth 3"
          },
          {
            input: "null",
            expectedOutput: 0,
            description: "Empty tree"
          },
          {
            input: "TreeNode(1)",
            expectedOutput: 1,
            description: "Single node tree"
          }
        ],
        timeLimit: 30
      }
    },
    'Python': {
      'Easy': {
        id: 4,
        title: "Two Sum Problem",
        description: "Given a list of integers `nums` and an integer `target`, find two distinct numbers in the list that add up to the target. Return the indices of the two numbers that add up to the target. You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nExample: nums = [2, 7, 11, 15], target = 9\nReturn [0, 1] because nums[0] + nums[1] == 9.",
        difficulty: "Easy",
        techStack: "Python",
        starterCode: `def two_sum(nums, target):
    # Your code here
    return []

# Test your function
print(two_sum([2, 7, 11, 15], 9))  # Should return [0, 1]`,
        testCases: [
          {
            input: [[2, 7, 11, 15], 9],
            expectedOutput: [0, 1],
            description: "Numbers at index 0 and 1 add up to 9"
          },
          {
            input: [[3, 2, 4], 6],
            expectedOutput: [1, 2],
            description: "Numbers at index 1 and 2 add up to 6"
          },
          {
            input: [[3, 3], 6],
            expectedOutput: [0, 1],
            description: "Duplicate numbers at different indices"
          }
        ],
        timeLimit: 30
      },
      'Medium': {
        id: 5,
        title: "Word Frequency Counter",
        description: "Write a function that counts the frequency of each word in a given text. Return a dictionary with words as keys and their counts as values. Ignore case and punctuation.",
        difficulty: "Medium",
        techStack: "Python",
        starterCode: `def word_frequency(text):
    # Your code here
    pass

# Test your function
print(word_frequency("hello world hello"))  # Should return {'hello': 2, 'world': 1}`,
        testCases: [
          {
            input: "hello world hello",
            expectedOutput: {'hello': 2, 'world': 1},
            description: "Simple word counting"
          },
          {
            input: "The quick brown fox jumps over the lazy dog",
            expectedOutput: {'the': 2, 'quick': 1, 'brown': 1, 'fox': 1, 'jumps': 1, 'over': 1, 'lazy': 1, 'dog': 1},
            description: "Sentence with repeated words"
          },
          {
            input: "",
            expectedOutput: {},
            description: "Empty string"
          }
        ],
        timeLimit: 30
      }
    },
    'Java': {
      'Easy': {
        id: 6,
        title: "Array Reverse",
        description: "Write a method that reverses an array of integers in-place. Modify the original array without creating a new one.",
        difficulty: "Easy",
        techStack: "Java",
        starterCode: `public class Solution {
    public void reverseArray(int[] arr) {
        // Your code here
    }
}`,
        testCases: [
          {
            input: [1, 2, 3, 4, 5],
            expectedOutput: [5, 4, 3, 2, 1],
            description: "Reverse array of positive numbers"
          },
          {
            input: [],
            expectedOutput: [],
            description: "Empty array"
          },
          {
            input: [42],
            expectedOutput: [42],
            description: "Single element array"
          }
        ],
        timeLimit: 30
      }
    },
    'Generic': {
      'Easy': {
        id: 7,
        title: "Two Sum Problem",
        description: "Given an array of integers and a target sum, return the indices of two numbers that add up to the target. You may assume exactly one solution exists.",
        difficulty: "Easy",
        techStack: "Generic",
        starterCode: `// Choose your preferred language and implement:
function twoSum(nums, target) {
    // Your code here (JavaScript)
}

/*
def two_sum(nums, target):
    # Your code here (Python)
    pass

public int[] twoSum(int[] nums, int target) {
    // Your code here (Java)
}
*/`,
        testCases: [
          {
            input: "nums=[2,7,11,15], target=9",
            expectedOutput: [0, 1],
            description: "Numbers at index 0 and 1 add up to 9"
          },
          {
            input: "nums=[3,2,4], target=6",
            expectedOutput: [1, 2],
            description: "Numbers at index 1 and 2 add up to 6"
          }
        ],
        timeLimit: 30
      }
    }
  };

  const techChallenges = challenges[techStack as keyof typeof challenges];
  if (techChallenges) {
    const difficultyChallenge = techChallenges[difficulty as keyof typeof techChallenges];
    if (difficultyChallenge) {
      return difficultyChallenge;
    }
  }

  // Ultimate fallback
  return {
    id: 999,
    title: `${techStack} Coding Challenge`,
    description: `Write a function that demonstrates your ${techStack} programming skills at ${difficulty} level. Implement a solution that shows clean code practices and problem-solving abilities.`,
    difficulty,
    techStack,
    starterCode: `// Write your ${techStack} solution here
function solution() {
    // Your code here
    return "Hello, World!";
}

// Test your solution
console.log(solution());`,
    testCases: [
      {
        input: "basic test",
        expectedOutput: "expected output",
        description: "Basic functionality test"
      }
    ],
    timeLimit: 30
  };
};

export const executeCode = async (code: string, language: string, testCases: any[]) => {
  console.log(`🤖 Executing ${language} code using Gemini AI`);
  
  try {
    // Import Gemini service dynamically to avoid circular imports
    const { geminiService } = await import('./geminiService');
    
    // Use Gemini to execute the code
    const result = await geminiService.executeCode(code, language, testCases);
    
    console.log('✅ Code execution successful using Gemini AI');
    return result;
    
  } catch (error) {
    console.error('❌ Gemini code execution failed:', error);
    
    // Fallback to backend execution if Gemini fails
    console.log('🔄 Falling back to backend execution...');
    return await executeCodeWithBackend(code, language, testCases);
  }
};

// Fallback function to use backend execution
const executeCodeWithBackend = async (code: string, language: string, testCases: any[]) => {
  const maxRetries = 3;
  const retryDelay = 1000; // 1 second

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(`🔄 Backend code execution attempt ${attempt}/${maxRetries}`);
      
      const response = await fetch(`${API_URL}/code/execute`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify({
          code,
          language,
          testCases,
        }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error(`❌ Server responded with ${response.status}: ${errorText}`);
        throw new Error(`Code execution failed: ${response.status} ${response.statusText}`);
      }

      const result = await response.json();
      console.log(`✅ Backend code execution successful on attempt ${attempt}`);
      return result;

    } catch (error) {
      console.error(`❌ Backend code execution attempt ${attempt} failed:`, error);
      
      // Don't retry for certain errors
      if (error instanceof Error) {
        if (error.message.includes('CORS') || 
            error.message.includes('400') || 
            error.message.includes('401') || 
            error.message.includes('403')) {
          throw error; // Don't retry client errors
        }
      }

      // If this was the last attempt, throw the error
      if (attempt === maxRetries) {
        if (error instanceof Error && error.message.includes('Failed to fetch')) {
          throw new Error('Failed to fetch - Unable to connect to the server. Please check if the backend is running and try again.');
        }
        throw error;
      }

      // Wait before retrying
      console.log(`⏳ Waiting ${retryDelay}ms before retry...`);
      await new Promise(resolve => setTimeout(resolve, retryDelay));
    }
  }
};
